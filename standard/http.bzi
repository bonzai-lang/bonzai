require "std:datatypes/error"
require "std:datatypes/tuple"
require "std:datatypes/string"
require "math"
require "std:datatypes/mutable"
require "std:datatypes/list"
require "std:io"
require "std:datatypes/map"
require "std:datatypes/unit"
require "std:datatypes/optional"
require "std:datatypes/threads"

extern fn start_http_server(port: int): HTTP
extern fn accept_request(server: HTTP): Request
extern fn close_client(req: Request)
extern fn get_buffer(req: Request): string
pub extern fn send_buffer(req: Request, buffer: string)
pub extern fn send_buffer_with(req: Request, buffer: string)
extern fn close_server(server: HTTP)
extern fn redirect_to(req: Request, url: string): unit
extern fn get_path(req: Request): string
pub extern fn make_unit(): unit

fn HTTP::create(callback: fn(Request): bool, port: int) => {
  let server = start_http_server(port)
  
  mut running = true

  while running.value {
    let req = accept_request(server)
    running = callback(req)
    close_client(req)
  }

  close_server(server)
} 

pub extern fn fetch_helper(url: string, method: string, headers: string): Throwable<(string, string)>

pub fn Dynamic::mapToHeaders(headers: Dynamic): string => {
  mut headersString = ""
  mut i = 0
  
  match headers {
    case Dyn::Map(entries) => {
      let Map(xs) = entries

      while i.value < List::length(xs) {
        match xs[i.value] {
          case Tuple(key, val) => {
            let valAsString = Dynamic::toString(val)
            headersString = headersString.value + "$key: $valAsString\r\n"
            i = i.value + 1
          }
        }
      }
    }
  }

  headersString.value
}

pub fn fetch(url: string, options: Optional<Dynamic>): Throwable<(string, string)> => {
  match options {
    case Some(options) => {
      let method = Dynamic::get(options, "method")
      let body = Dynamic::get(options, "body")
      let headers = Dynamic::get(options, "headers")
      
      let Dyn::String(methodString) = Optional::unwrap_or(method, Dyn::String("GET"))
      let Dyn::String(bodyString) = Optional::unwrap_or(body, Dyn::String(""))

      match headers {
        case Some(headers) => {
          let headersString = Dynamic::mapToHeaders(headers) + "\r\n" + bodyString

          fetch_helper(url, methodString, headersString)
        }
        case None => fetch_helper(url, methodString, bodyString)
      }
    }
    case None => fetch_helper(url, "GET", "")
  }
}

type Header {
  Header(code: int, reason: string)
}

pub fn Header::show(header: Header): string => match header {
  case Header(code, reason) => "HTTP/1.1 $code $reason"
}

pub fn Map::mapToHeaders(headers: Map<string>): string => {
  mut headersString = ""
  mut i = 0
  
  match headers {
    case Map(entries) => {
      while i.value < List::length(entries) {
        match entries[i.value] {
          case Tuple(key, val) => {
            headersString = headersString.value + "$key: $val\r\n"
            i = i.value + 1
          }
        }
      }
    }
  }

  headersString.value
}

fn respondHeaders(req: Request, buffer: Map<string>, header_line: Header, content: string) => {
  let headers = Map::mapToHeaders(buffer)

  req.send_buffer_with(Header::show(header_line) + "\r\n" + headers + "\r\n" + content)
}

fn respondOk(req: Request, buffer: Map<string>, content: string) => {
  respondHeaders(req, buffer, Header(200, "OK"), content)
}

fn respondText(req: Request, ty: string, content: string) =>
  req.respondOk({
    "Content-Type": ty,
    "Content-Length": String::length(content).toString,
    "Connection": "close"
  }, content)
