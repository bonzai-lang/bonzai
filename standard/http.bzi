require "std:datatypes/error"
require "std:datatypes/tuple"
require "std:datatypes/string"
require "math"
require "std:datatypes/mutable"
require "std:datatypes/list"
require "std:io"
require "std:datatypes/map"
require "std:datatypes/unit"
require "std:datatypes/optional"
require "std:datatypes/threads"

extern fn start_http_server(port: int): HTTP
extern fn accept_request(server: HTTP): Request
extern fn close_client(req: Request): unit
extern fn get_buffer(req: Request): string
pub extern fn send_buffer(req: Request, buffer: string): unit
pub extern fn send_buffer_with(req: Request, buffer: string): unit
extern fn close_server(server: HTTP): unit
extern fn redirect_to(req: Request, url: string): unit
extern fn get_path(req: Request): string
pub extern fn make_unit(): unit

fn containsContentLength(headers: list<string>): bool => {
  let contentLengthHeader = "Content-Length: "

  List::any(
    headers,
    fn(header) => String::startsWith(header, contentLengthHeader)
  )
}

pub fn HTTP::create(callback: fn({
  send: fn(string): unit,
  sendWith: fn(string): unit,
  get: fn(): string,
  getPath: fn(): string,
  redirect: fn(string): unit
}): bool, port: int) => {
  let server = start_http_server(port)

  mut running = true

  fn generateRequest(req: Request) => {
    send: fn(buffer: string) => send_buffer(req, buffer),
    sendWith: fn(buffer: string) => send_buffer_with(req, buffer),
    get: fn() => get_buffer(req),
    getPath: fn() => get_path(req),
    redirect: fn(url: string) => redirect_to(req, url)
  }

  while running.value {
    let req = accept_request(server)
    running = callback(generateRequest(req))
    close_client(req)
  }

  close_server(server)
}

pub fn Request::getPath(req: Request): string => get_path(req)
pub fn Request::getBuffer(req: Request): string => get_buffer(req)
pub fn Request::send(req: Request, buffer: string): unit => send_buffer(req, buffer)
pub fn Request::redirect(req: Request, url: string): unit => redirect_to(req, url)

extern fn fetch_helper(url: string, method: string, headers: string): Throwable<(string, string)>

pub fn fetch(
  url: string,
  method _?: string,
  body _?: string,
  headers _?: list<string>
): Throwable<(string, string)> => {
  let method = kwargs->method
  let body = kwargs->body
  let headers = kwargs->headers

  let methodString = Optional::unwrap_or(method, "GET")
  let bodyString = Optional::unwrap_or(body, "")

  match headers {
    case Some(headers) => {
      mut newHeaders = headers
      if !containsContentLength(headers) then {
        let len = String::length(bodyString)
        newHeaders += ["Content-Length: $len"]
      }

      let headersString = String::join(newHeaders.value, "\r\n") + "\r\n\r\n" + bodyString

      fetch_helper(url, methodString, headersString)
    }
    case None => fetch_helper(url, methodString, bodyString)
  }
}

type Header {
  Header(toplevel: string, rules: list<(string, string)>, content: string)
}

pub fn Header::from(headers: string): Optional<Header> => {
  let result = String::split(headers, "\r\n\r\n")

  match result {
    case [headers, content .. _] => {
      let headerLines = String::split(headers, "\r\n")
      match headerLines {
        case [toplevel .. headerLines] => {
          let rules = List::map(headerLines, fn(line) => {
            let parts = String::split(line, ": ");

            match parts {
              case [key, value] => (key, value)
              case _ => ("", "")
            }
          })

          Some(Header(toplevel, rules, content))
        }

        case [] => None
      }
    }

    case _ => None
  }
}

pub fn Header::show(Header(toplevel, rules, content)): string => {
  let rulesString = List::map(rules, fn(Tuple(key, value)) => "$key: $value")

  let rulesJoined = String::join(rulesString, "\r\n")

  let headerString = "$toplevel\r\n$rulesJoined\r\n\r\n$content"

  headerString
}
