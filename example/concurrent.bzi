require "std:foundation"

extern fn queue_create<A>(): Queue<A>
extern fn queue_enqueue<A>(q: Queue<A>, x: A): unit
extern fn queue_dequeue<A>(q: Queue<A>, should_stop: mut bool): A
extern fn queue_destroy<A>(q: Queue<A>): unit
extern fn queue_show<A>(q: Queue<A>): unit

fn Actor::create<A>(events: list<(string, fn(A): bool)>): (Queue<(string, A)>, Thread<unit>) => {
  let q = queue_create();
  let thread = spawn {
    mut running = true

    while running.value {
      let x = queue_dequeue(q, running)

      match x {
        case Some((event, data)) => match List::lookup(event, events) {
          case Some(fun) => {
            running = fun(data)
          }

          case None => {
            print("Unknown event: $event")
          }
        }

        case None => unit
      }
    }

    unit
  };

  (q, thread)
}

fn Actor::send<A>(act: (Queue<(string, A)>, Thread<unit>), event: string, data: A): unit => {
  let (q, _) = act
  queue_enqueue(q, (event, data))
}

fn Actor::wait<A>(act: (Queue<(string, A)>, Thread<unit>)): unit => {
  let (_, thread) = act
  thread.wait()
}

type Message {
  Say(msg: string),
  Exit,
  Welcome(user: string)
}

let act = Actor::create([
  ("Say", fn(Say(msg)) => {
    print("Message: $msg")
    return true
  }),
  ("Exit", fn(Exit) => {
    print("Exiting...")
    return false
  }),
  ("Welcome", fn(Welcome(user)) => {
    print("Welcome, $user!")
    return true
  })
])

range(0, 1000).foreach(fn (i) => {
  Actor::send(act, "Say", Say("Hello, world! $i"))
})

Actor::send(act, "Exit", Exit)

Actor::wait(act)

print("===================================")
