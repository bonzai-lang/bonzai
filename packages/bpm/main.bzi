require "std:foundation"
require "std:language/parser": 
  satisfy, many, right, left, Parser::bind, 
  Parser::map, noneOf, is_whitespace, is_alphanumeric, 
  implode, explode, many1, choice, runParser

extern fn get_args(): list<string>
extern fn slice<A>(xs: list<A>, start: int, end: int): list<A>
extern fn get_cwd(): string
extern fn file_exists(path: string): bool
extern fn get_env(name: string): string
extern fn execute_command(command: string)
extern fn execute_command_silent(command: string)
extern fn length<A>(xs: list<A>): int

type CLI {
  Command(name: string, description: string, action: fn(list<string>): unit)
}

type Argument {
  Option(name: string, value: string),
  Argument(value: string),
  Flag(name: string)
}

fn parseCLI(args: list<string>) => {
  fn lex<A>(p: Parser<A>): Parser<A> => {
    let ws = satisfy(is_whitespace).many()
    ws :right: p :left: ws
  }

  fn parseArgument() => {
    let ws = satisfy(is_whitespace).many()
    let minus = satisfy(fn(x) => x == '-')

    let optionParser = minus :right: satisfy(is_alphanumeric).many1() :Parser::bind: fn(flag) =>
      ws :right: noneOf([' ']).many1() :left: ws :Parser::map: fn(value) => Option(flag.implode, value.implode)
      
    let argumentParser = noneOf([' ']).many1() :Parser::map: fn(value) => Argument(value.implode)

    let flagParser = minus :right: satisfy(is_alphanumeric).many1() :Parser::map: fn(flag) => Flag(flag.implode)
    let biflagParser = minus :right: minus :right: satisfy(is_alphanumeric).many1() :Parser::map: fn(flag) => Flag(flag.implode)

    choice([optionParser, flagParser, biflagParser, argumentParser])
  };

  let parser = parseArgument().lex.many()

  let formattedArgs = List::concat(List::join(args.map(explode), [' ']))

  parser.runParser(formattedArgs)
}

print(parseCLI(get_args()))