require "std:datatypes/error"
require "std:datatypes/tuple"
require "std:datatypes/string"
require "math"
require "std:datatypes/mutable"
require "std:datatypes/list"
require "std:io"
require "std:datatypes/map"
require "std:datatypes/unit"
require "std:datatypes/optional"
require "std:datatypes/threads"

extern fn start_http_server(port: int): HTTP
extern fn accept_request(server: HTTP): Request
extern fn close_client(req: Request)
extern fn get_buffer(req: Request): string
pub extern fn send_buffer(req: Request, buffer: string)
pub extern fn send_buffer_with(req: Request, buffer: string)
extern fn close_server(server: HTTP)
extern fn redirect_to(req: Request, url: string): unit
extern fn get_path(req: Request): string
pub extern fn make_unit(): unit
extern fn map_headers_to_string<A>(headers: A): string

fn HTTP::create(callback: fn(Request): bool, port: int) => {
  let server = start_http_server(port)
  
  mut running = true

  while running.value {
    let req = accept_request(server)
    running = callback(req)
    close_client(req)
  }

  close_server(server)
} 

pub extern fn fetch_helper(url: string, method: string, headers: string): Throwable<(string, string)>

pub fn fetch(
  url: string, 
  method _: Optional<string>,
  body _: Optional<string>,
  headers _: Optional<list<string>>
): Throwable<(string, string)> => {
  let method = kwargs->method
  let body = kwargs->body
  let headers = kwargs->headers

  let methodString = Optional::unwrap_or(method, "GET")
  let bodyString = Optional::unwrap_or(body, "")

  match headers {
    case Some(headers) => {
      let headersString = String::join(headers, "\r\n") + "\r\n" + bodyString

      fetch_helper(url, methodString, headersString)
    }
    case None => fetch_helper(url, methodString, bodyString)
  }
}

type Header {
  Header(code: int, reason: string)
}

pub fn Header::show(header: Header): string => match header {
  case Header(code, reason) => "HTTP/1.1 $code $reason"
}
