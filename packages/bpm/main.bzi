require "std:foundation"
require "std:language/parser": 
  satisfy, many, right, left, Parser::bind, 
  Parser::map, noneOf, is_whitespace, is_alphanumeric, 
  implode, explode, many1, choice, runParser

extern fn get_args(): list<string>
extern fn slice<A>(xs: list<A>, start: int, end: int): list<A>
extern fn get_cwd(): string
extern fn file_exists(path: string): bool
extern fn get_env(name: string): string
extern fn execute_command(command: string)
extern fn execute_command_silent(command: string)
extern fn length<A>(xs: list<A>): int

type CLI {
  Command(name: string, description: string, action: fn(list<Argument>): unit)
}

type Argument {
  Option(name: string, value: string),
  Argument(value: string),
  Flag(name: string)
}

fn parseCLI(args: list<string>) => {
  fn lex<A>(p: Parser<A>): Parser<A> => {
    let ws = satisfy(is_whitespace).many()
    ws :right: p :left: ws
  }

  fn parseArgument() => {
    let minus = satisfy(fn(x) => x == '-')

    let optionParser = minus :right: satisfy(is_alphanumeric).many1() :Parser::bind: fn(flag) =>
      noneOf([' ']).many1().lex() :Parser::map: fn(value) => Option(flag.implode, value.implode)

    let bioptionParser = minus :right: minus :right: satisfy(is_alphanumeric).many1() :Parser::bind: fn(flag) =>
      noneOf([' ']).many1().lex() :Parser::map: fn(value) => Option(flag.implode, value.implode)
      
    let argumentParser = noneOf([' ']).many1() :Parser::map: fn(value) => Argument(value.implode)

    let flagParser = minus :right: satisfy(is_alphanumeric).many1() :Parser::map: fn(flag) => Flag(flag.implode)
    let biflagParser = minus :right: minus :right: satisfy(is_alphanumeric).many1() :Parser::map: fn(flag) => Flag(flag.implode)

    choice([optionParser, bioptionParser, flagParser, biflagParser, argumentParser])
  };

  let parser = parseArgument().lex.many()

  let formattedArgs = List::concat(List::join(args.map(explode), [' ']))

  parser.runParser(formattedArgs)
}

fn interpretCLIResult(cli: list<Argument>): (string, list<Argument>) => {
  match cli {
    case [Argument(value) .. args] => (value, args)
    case _ => ("", cli)
  }
}

fn runCLI(commands: list<CLI>, args: list<string>) => {
  let result = parseCLI(args.sliceFrom(4))

  match result {
    case ParseResult(x, _) => {
      let Tuple(cmd, args) = interpretCLIResult(x)

      let command = List::find(fn(Command(name, _, _)) => name == cmd, commands)

      match command {
        case Some(Command(_, _, action)) => action(args)
        case None => print("Command not found")
      }
    } 

    case ParseError(msg, _) => print(msg)
  }
}

let commands = [
  Command("help", "Display help", fn(args) => {
    print("Help")
  }),
  Command("version", "Display version", fn(args) => {
    print("Version")
  })
]

runCLI(commands, get_args())