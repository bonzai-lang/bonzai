extern fn print<A>(x: A)
extern fn map<A, B>(f: fn(A): B, xs: list<A, B>): list<B>
extern fn mul_value<A>(x: A, y: A): A
extern fn add_value<A>(x: A, y: A): A
extern fn sub_value<A>(x: A, y: A): A
extern fn div_value<A>(x: A, y: A): A
extern fn exit_with<A>(code: int): A
extern fn mutable_value<A>(x: mutable<A>): A

extern fn length<A>(xs: list<A>): int
extern fn sliceFrom<A>(xs: list<A>, i: int): list<A>

extern fn and_value(x: bool, y: bool): bool
extern fn or_value(x: bool, y: bool): bool
extern fn not_value(x: bool): bool

extern fn panic<A>(msg: string): A

extern fn eq_value<A>(x: A, y: A): bool
extern fn neq_value<A>(x: A, y: A): bool
extern fn lt_value<A>(x: A, y: A): bool
extern fn gt_value<A>(x: A, y: A): bool
extern fn lte_value<A>(x: A, y: A): bool
extern fn gte_value<A>(x: A, y: A): bool

// Defining basic functions

let value = mutable_value
fn exit() => exit_with(0)

let (==) = eq_value
let (!=) = neq_value
let (<) = lt_value
let (>) = gt_value
let (<=) = lte_value
let (>=) = gte_value

let (+) = add_value
let (-) = sub_value
let (*) = mul_value
let (/) = div_value

fn (&&) (x: bool, y: bool): bool => if x then y else false
fn (||) (x: bool, y: bool): bool => if x then true else y
fn (!) (x: bool): bool => if x then false else true

fn List::elem<A>(x: A, xs: list<A>): bool =>
  match xs {
    case [] => false
    case [y .. ys] => if x == y then true else List::elem(x, ys)
  }

fn List::map<A, B>(xs: list<A>, f: fn(A): B): list<B> =>
  match xs {
    case [] => []
    case [y .. ys] => [f(y)] + List::map(ys, f)
  }

fn List::foldl<A, B>(f: fn(A, B): B, acc: B, xs: list<A>): B =>
  match xs {
    case [] => acc
    case [y .. ys] => List::foldl(f, f(y, acc), ys)
  }

fn List::foldr<A, B>(f: fn(A, B): B, acc: B, xs: list<A>): B =>
  match xs {
    case [] => acc
    case [y .. ys] => f(y, List::foldr(f, acc, ys))
  }

fn List::length<A>(xs: list<A>): int =>
  match xs {
    case [] => 0
    case [x .. xs] => 1 + List::length(xs)
  }
