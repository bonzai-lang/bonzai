require "std:datatypes/optional"
require "std:language/parser"
require "std:datatypes/tuple": Tuple::first, Tuple, Tuple::second, Map::toList
require "std:datatypes/list"
require "std:datatypes/map"
require "std:datatypes/string"
require "std:math"
require "std:datatypes/error"
require "std:datatypes/unit"
require "std:io"
require "std:datatypes/mutable"

pub type JSON {
  Object(fields: list<(string, JSON)>),
  Array(values: list<JSON>),
  String(value: string),
  Integer(value: int),
  Float(value: float),
  Boolean(value: bool),
  Null
}

pub let json = {
  object: fn(fields: list<(string, JSON)>) => Object(fields),
  array: fn(values: list<JSON>) => Array(values),
  string: fn(value: string) => String(value),
  integer: fn(value: int) => Integer(value),
  float: fn(value: float) => Float(value),
  boolean: fn(value: bool) => Boolean(value),
  null: Null
}

fn jsonParser(): fn(list<char>): Result<JSON> => {
  let charLiteral = Parser::choice([
    Parser::char('\\') :Parser::right: Parser::char('\\'),
    Parser::char('\\') :Parser::right: Parser::char('"'),
    Parser::char('\\') :Parser::right: Parser::char('/'),
    Parser::char('\\') :Parser::right: Parser::char('b')  
      :Parser::bind: fn(_) => fn(input) => ParseResult('\b', input),
    Parser::char('\\') :Parser::right: Parser::char('f')  
      :Parser::bind: fn(_) => fn(input) => ParseResult('\f', input),
    Parser::char('\\') :Parser::right: Parser::char('n')  
      :Parser::bind: fn(_) => fn(input) => ParseResult('\n', input),
    Parser::char('\\') :Parser::right: Parser::char('r')
      :Parser::bind: fn(_) => fn(input) => ParseResult('\r', input),
    Parser::char('\\') :Parser::right: Parser::char('t')
      :Parser::bind: fn(_) => fn(input) => ParseResult('\t', input)
  ])

  let ws = Parser::many(Parser::satisfy(is_whitespace))

  let str = Parser::char('"') 
            :Parser::right: (Parser::many(Parser::or(charLiteral, Parser::satisfy(fn (x) => x != '"')))
              :Parser::map: fn(xs) => String(xs.implode()))
            :Parser::left: Parser::char('"')

  let integer = Parser::satisfy(is_digit).Parser::many1() :Parser::map: fn(xs) => Integer(xs.implode().toInt())

  let float = integer 
            :Parser::bind: fn(intPart) => Parser::char('.')
            :Parser::andThen: integer
            :Parser::map: fn(fracPart) => 
              Float((intPart.toString() + "." + fracPart.toString()).toFloat())

  let boolean = Parser::choice([
    Parser::string("true") :Parser::map: fn(_) => Boolean(true),
    Parser::string("false") :Parser::map: fn(_) => Boolean(false)
  ])

  let null = Parser::string("null") :Parser::map: fn(_) => Null

  let value = ws :Parser::right: Parser::choice([
    str,
    integer,
    float,
    boolean,
    null
  ]) :Parser::left: ws

  let array = Parser::char('[') 
              :Parser::right: Parser::lazy(jsonParser).Parser::sepBy(Parser::char(','))
              :Parser::left: Parser::char(']')
              :Parser::map: fn(xs) => Array(xs)

  let field = Parser::char('"') 
              :Parser::right: (Parser::satisfy(fn (x) => x != '"').Parser::many()
                :Parser::map: fn(xs) => xs.implode())
              :Parser::left: Parser::char('"')
              :Parser::bind: fn (key) =>
              ws :Parser::right: Parser::char(':') :Parser::left: ws
              :Parser::andThen: Parser::lazy(jsonParser)
              :Parser::map: fn(value) => (key, value)

  let object = Parser::char('{') 
              :Parser::right: ws
              :Parser::right: field.Parser::sepBy(ws :Parser::left: Parser::char(',') :Parser::right: ws)
              :Parser::left: ws
              :Parser::left: Parser::char('}')
              :Parser::map: fn(xs) => Object(xs)

  Parser::choice([object, array, value])
}

fn parseJsonWithError(input: string): Throwable<JSON> => 
  match jsonParser()(input.explode()) {
    case ParseResult(x, _) => Ok(x)
    case ParseError(msg, _) => Error(msg)
  }

fn parseJSON(input: string): Optional<JSON> => 
  match jsonParser()(input.explode()) {
    case ParseResult(x, _) => Some(x)
    case ParseError(_, _) => None
  }

fn getJSON(input: string): JSON =>
  match parseJSON(input) {
    case Some(x) => x
    case None => Null
  }

pub fn JSON::parse(input: string): JSON => getJSON(input)

pub fn JSON::stringify(json: JSON): string =>
  match json {
    case Object(fields) => {
      let pairs = List::map(fields, fn (v) => 
        "\"" 
          + Tuple::first(v) 
          + "\":" 
          + JSON::stringify(Tuple::second(v))
      )

      "{" + String::join(pairs, ",") + "}"
    }
    case Array(values) => 
      "[" + String::join(List::map(values, JSON::stringify), ",") + "]"
    case String(val) => "\"" + val + "\""
    case Integer(val) => val.toString()
    case Float(val) => val.toString()
    case Boolean(val) => if val then "true" else "false"
    case Null => "null"
  }

pub fn getKey(json: JSON, key: string): Optional<JSON> =>
  match json {
    case Object(fields) => {
      List::foldl(fn (field, acc) =>
        match acc {
          case Some(x) => Some(x)
          case None => 
            if Tuple::first(field) == key 
              then Some(Tuple::second(field)) 
              else None
        },
        None,
        fields
      )
    }
    case _ => None
  }

pub fn getKeys(json: JSON, keys: list<string>): Optional<JSON> =>
  List::foldl(fn (key, acc) =>
    match acc {
      case Some(x) => getKey(x, key)
      case None => None
    },
    Some(json),
    keys
  )

pub fn JSON::prettify(json: JSON, tabs _?: int): string => {
  let i = Optional::unwrap_or(kwargs->tabs, 0)  

  match json {
    case Object(fields) => {
      let pairs = List::map(fields, fn (v) => 
        String::concat([
          String::repeat(" ", i + 2), 
          "\"", 
          Tuple::first(v), 
          "\": ", 
          JSON::prettify(Tuple::second(v), tabs: i + 2)
        ])
      )

      String::concat([
        "{\n", 
        String::repeat(" ", i), 
        String::join(pairs, ",\n"), 
        "\n", 
        String::repeat(" ", i), 
        "}"
      ])
    }
    case Array(values) => {
      let items = List::map(values, fn (v) => 
        String::concat([
          "\n", 
          String::repeat(" ", i + 2), 
          JSON::prettify(v, tabs: i + 2)
        ])
      )

      String::concat([
        "[", 
        String::repeat(" ", i), 
        String::join(items, ","), 
        "\n", 
        String::repeat(" ", i), 
        "]"
      ])
    }
    case _ => JSON::stringify(json)
  }
}