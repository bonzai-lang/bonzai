require "std:datatypes/error"
require "std:datatypes/tuple"
require "std:datatypes/string"
require "math"
require "std:datatypes/mutable"
require "std:datatypes/list"
require "std:io"
require "std:datatypes/map"
require "std:datatypes/unit"
require "std:datatypes/optional"
require "std:datatypes/threads"

extern fn start_http_server(port: int): HTTP
extern fn accept_request(server: HTTP): Request
extern fn close_client(req: Request)
extern fn get_buffer(req: Request): string
pub extern fn send_buffer(req: Request, buffer: string)
pub extern fn send_buffer_with(req: Request, buffer: string)
extern fn close_server(server: HTTP)
extern fn redirect_to(req: Request, url: string): unit
extern fn get_path(req: Request): string
pub extern fn make_unit(): unit

fn containsContentLength(headers: list<string>): bool => {
  let contentLengthHeader = "Content-Length: "
  
  List::any(
    headers, 
    fn(header) => String::startsWith(header, contentLengthHeader)
  )
}

pub fn HTTP::create(callback: fn({
  send: fn(string): unit,
  sendWith: fn(string): unit,
  get: fn(): string,
  getPath: fn(): string,
  redirect: fn(string): unit
}): bool, port: int) => {
  let server = start_http_server(port)
  
  mut running = true

  fn generateRequest(req: Request) => {
    send: fn(buffer: string) => send_buffer(req, buffer),
    sendWith: fn(buffer: string) => send_buffer_with(req, buffer),
    get: fn() => get_buffer(req),
    getPath: fn() => get_path(req),
    redirect: fn(url: string) => redirect_to(req, url)
  }

  while running.value {
    let req = accept_request(server)
    running = callback(generateRequest(req))
    close_client(req)
  }

  close_server(server)
} 

pub fn Request::getPath(req: Request): string => get_path(req)
pub fn Request::getBuffer(req: Request): string => get_buffer(req)
pub fn Request::send(req: Request, buffer: string): unit => send_buffer(req, buffer)
pub fn Request::redirect(req: Request, url: string): unit => redirect_to(req, url)

extern fn fetch_helper(url: string, method: string, headers: string): Throwable<(string, string)>

pub fn fetch(
  url: string, 
  method _?: string,
  body _?: string,
  headers _?: list<string>
): Throwable<(string, string)> => {
  let method = kwargs->method
  let body = kwargs->body
  let headers = kwargs->headers

  let methodString = Optional::unwrap_or(method, "GET")
  let bodyString = Optional::unwrap_or(body, "")

  match headers {
    case Some(headers) => {
      mut newHeaders = headers
      if !containsContentLength(headers) then {
        let len = String::length(bodyString)
        newHeaders += ["Content-Length: $len"]
      }

      let headersString = String::join(newHeaders.value, "\r\n") + "\r\n\r\n" + bodyString

      fetch_helper(url, methodString, headersString)
    }
    case None => fetch_helper(url, methodString, bodyString)
  }
}

type Header {
  Header(rules: list<(string, string)>, content: string)
}

pub fn Header::from(headers: string): Optional<Header> => {
  let result = String::split(headers, "\r\n")

  print(result)

  return None
}